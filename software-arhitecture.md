# Understanding Software Architecture: A Complete Guide Sarrah Pitaliya
https://sarrahpitaliya.medium.com/understanding-software-architecture-a-complete-guide-cb8f05900603

# Software architecture 
Архитектура программного обеспечения может быть разнообразной и зависит от требований к системе, контекста её использования и предпочтений команды разработчиков. Вот несколько основных видов архитектуры программного обеспечения:

### 1. Монолитная архитектура

- **Описание**: В монолитной архитектуре вся логика приложения обычно размещается в одном кодовом базисе и работает как единый процесс.
- **Применение**: Подходит для малых и средних приложений, где упрощение развертывания и управления является приоритетом.

### 2. Микросервисная архитектура

- **Описание**: Микросервисы разделяют большое приложение на меньшие, независимо развертываемые сервисы, каждый из которых выполняет определённую функцию.
- **Применение**: Используется для создания масштабируемых и гибких приложений, где каждая часть может быть разработана, развернута и масштабирована независимо.

### 3. Событийно-ориентированная архитектура (Event-Driven Architecture, EDA)

- **Описание**: В этом подходе компоненты системы реагируют на события. Это обеспечивает высокую асинхронность и децентрализацию процессов.
- **Применение**: Подходит для систем, требующих высокой реактивности и асинхронной обработки, например, в реальном времени.

### 4. Слоистая архитектура (Layered Architecture)

- **Описание**: Приложение разделяется на слои, где каждый слой имеет определённую роль (презентационный слой, бизнес-логика, слой данных).
- **Применение**: Традиционный подход для веб-приложений и информационных систем, где чёткое разделение ответственности является важным.

### 5. Сервис-ориентированная архитектура (Service-Oriented Architecture, SOA)

- **Описание**: Подход, при котором функциональность приложения предоставляется в виде набора взаимосвязанных сервисов, которые общаются через сетевые вызовы.
- **Применение**: Используется для интеграции различных бизнес-процессов и служб в единое приложение, часто в крупных корпоративных средах.

### 6. Клиент-серверная архитектура

- **Описание**: Разделение системы на две части: клиент, который запрашивает данные или услуги, и сервер, который их предоставляет.
- **Применение**: Широко используется в веб-приложениях и онлайн-сервисах.

### 7. Облачная архитектура

- **Описание**: Разработка приложений с учётом облачных ресурсов, включая масштабируемость, устойчивость к отказам и оптимизацию распределения ресурсов.
- **Применение**: Для приложений, требующих гибкости, масштабируемости и эффективного распределения ресурсов.

### 8. Бесшовная архитектура (Serverless Architecture)

- **Описание**: Приложения строятся вокруг облачных функций, которые активируются событиями, с минимальной необходимостью управления серверами.
- **Применение**: Для систем, где предпочтительно оптимизировать операционные расходы и автоматизировать управление инфраструктурой.

Эти архитектуры не являются взаимоисключающими и могут комбинироваться в зависимости от нужд проекта, чтобы обеспечить наилучшую производительность, масштабируемость и удобство поддержки.

# Aрхитектура фронтенда
Существует несколько подходов к архитектуре фронтенда, каждый из которых имеет свои особенности и преимущества.

Один из подходов — это архитектура на основе вертикальных слайсов, где каждый "слайс" или "фича" содержит все необходимые компоненты, относящиеся к ней: от бизнес-логики и состояния до UI элементов. Этот подход позволяет сосредоточиться на разработке конкретной функциональности, уменьшая связанность между разными частями приложения и упрощая рефакторинг и добавление новых фич. Эта модель также хорошо сочетается с чистой архитектурой, где приложение делится на слои (application, domain, lib, services, ui), что способствует лучшему разделению и управлению кодом.

Событийно-ориентированная архитектура, другой популярный подход, фокусируется на реакции системы на различные события. В такой архитектуре компоненты системы реагируют на события, что позволяет создавать гибкие и масштабируемые приложения. Примером может служить Java Swing, где разработчики реализуют слушателей событий для управления поведением приложения. Это обеспечивает высокую модульность и асинхронность, хотя и может усложнить отладку из-за множественных асинхронных цепочек действий.

Микроядерная архитектура включает в себя ядро системы и плагины или модули, добавляющие дополнительную функциональность. Ядро управляет загрузкой и выгрузкой модулей, обеспечивая гибкость и расширяемость. Этот подход часто используется в операционных системах и приложениях, где необходимо легко добавлять новую функциональность. Несмотря на то, что микроядерная архитектура может снижать производительность при использовании большого количества модулей, она облегчает портирование приложений и обеспечивает четкое разделение базовых и бизнес-ориентированных функций.

Выбор конкретной архитектуры зависит от специфики проекта, требований к масштабируемости, гибкости, производительности и других факторов.

# Design patterns
Паттерны проектирования (design patterns) — это проверенные решения для общих проблем, возникающих в процессе разработки программного обеспечения. Они представляют собой шаблоны, которые можно применять для решения конкретных задач в рамках определённого контекста. Паттерны помогают улучшить код, делая его более удобным для понимания, поддержки и расширения.

Паттерны проектирования обычно делятся на три основные категории:

### 1. Порождающие (Creational)
Эти паттерны связаны с процессом создания объектов и предназначены для управления этим процессом, особенно когда имеются специфические ограничения.

- **Singleton** (Одиночка): Гарантирует, что класс имеет только один экземпляр, и предоставляет глобальную точку доступа к нему.
- **Factory Method** (Фабричный метод): Определяет интерфейс для создания объекта, но позволяет подклассам изменять тип создаваемых объектов.
- **Abstract Factory** (Абстрактная фабрика): Создаёт семейство связанных объектов без спецификации их конкретных классов.
- **Builder** (Строитель): Позволяет создавать сложные объекты пошагово.
- **Prototype** (Прототип): Позволяет копировать или клонировать объекты, избегая повторного создания через стандартные способы.

### 2. Структурные (Structural)
Структурные паттерны описывают, как можно комбинировать объекты и классы для формирования больших структур, облегчая при этом архитектуру.

- **Adapter** (Адаптер): Позволяет объектам с несовместимыми интерфейсами работать вместе.
- **Composite** (Компоновщик): Состоит из объектов в древовидной структуре для представления иерархии от части к целому.
- **Proxy** (Прокси): Предоставляет заместительный объект, управляющий доступом к другому объекту.
- **Facade** (Фасад): Предоставляет упрощённый интерфейс к сложной системе подсистем.
- **Bridge** (Мост): Разделяет абстракцию и реализацию, чтобы они могли изменяться независимо друг от друга.

### 3. Поведенческие (Behavioral)
Поведенческие паттерны определяют, как классы и объекты взаимодействуют и распределяют обязанности.

- **Observer** (Наблюдатель): Позволяет объекту публиковать изменения своего состояния, и другим объектам подписываться на эти изменения.
- **Strategy** (Стратегия): Определяет семейство алгоритмов, инкапсулирует каждый из них и обеспечивает их взаимозаменяемость.
- **Command** (Команда): Превращает запросы в объекты, позволяя передавать их как аргументы при вызове методов.
- **State** (Состояние): Позволяет объекту изменять своё поведение в зависимости от своего состояния.
- **Mediator** (Посредник): Уменьшает связанность множества классов, обеспечивая управление их вз

аимодействием через централизованный посредник.

Использование паттернов проектирования не является универсальным решением всех проблем программирования, но они предоставляют проверенные шаблоны для решения часто встречающихся задач, что может значительно упростить процесс разработки и улучшить качество программного обеспечения.

# DRY, KISS, YAGNI
Да, DRY, KISS и YAGNI — это известные принципы в разработке программного обеспечения, направленные на упрощение процесса разработки и улучшение качества кода. Вот краткое описание каждого из них:

### DRY (Don’t Repeat Yourself — Не повторяйся)

Этот принцип гласит, что каждый кусок знаний в системе должен иметь единственное, недвусмысленное и авторитетное представление. Применение DRY означает, что следует избегать дублирования кода, вынося повторяющуюся логику в общие функции или компоненты, что упрощает поддержку и модификацию программы.

### KISS (Keep It Simple, Stupid — Делай вещи проще)

KISS — это принцип проектирования, который утверждает, что системы работают лучше, если они остаются простыми и не усложняются без необходимости. Проще говоря, следует стремиться к самому простому решению проблемы, избегая ненужной сложности и не добавляя лишних функций "на всякий случай".

### YAGNI (You Ain’t Gonna Need It — Вам это не понадобится)

YAGNI предупреждает о том, что следует добавлять функциональность только тогда, когда она действительно необходима, и не стоит тратить время и усилия на реализацию функций, о которых "может быть" попросят в будущем. Следование этому принципу помогает избежать излишней работы и поддерживает фокус на текущих требованиях проекта.

Эти принципы направлены на минимизацию излишнего кода и функциональности, упрощение процесса разработки и поддержки, а также на сосредоточение усилий на реальных требованиях и задачах. Использование DRY, KISS и YAGNI в сочетании может помочь создавать более чистый, понятный и поддерживаемый код, ускоряя разработку и снижая риск ошибок.