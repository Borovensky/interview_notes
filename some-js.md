# Event capturing (перехват событий) 
Event capturing (перехват событий) — это одна из фаз в модели распространения событий в DOM (Document Object Model). В DOM события распространяются в три этапа: capturing phase (фаза перехвата), target phase (фаза цели), и bubbling phase (фаза всплывания).

### Как работает Event Capturing

1. **Capturing phase (Фаза перехвата)**: Событие начинает свой путь от корня документа (`window`) и двигается вниз к целевому элементу, проходя через всех предков элемента. В этой фазе, обработчики событий могут перехватывать событие на его пути к цели, если они зарегистрированы как обработчики для фазы перехвата.

2. **Target phase (Фаза цели)**: Событие достигает целевого элемента, на котором оно было инициировано. Здесь обработчики событий на целевом элементе могут отреагировать на событие.

3. **Bubbling phase (Фаза всплывания)**: После достижения цели, событие начинает "всплывать" вверх по дереву DOM от целевого элемента к корню документа, проходя через всех предков элемента. Обработчики, установленные на этих предках для фазы всплывания, могут теперь обработать событие.

### Пример

В JavaScript, чтобы установить обработчик событий на фазу перехвата, вы должны передать `true` в качестве третьего аргумента в метод `addEventListener`:

```javascript
element.addEventListener('click', function(event) {
    // Обработчик для фазы перехвата
    console.log('Capturing phase on ' + event.currentTarget.tagName);
}, true);  // `true` указывает на фазу перехвата
```

Если третий аргумент `false` или опущен, обработчик сработает на фазе всплывания:

```javascript
element.addEventListener('click', function(event) {
    // Обработчик для фазы всплывания
    console.log('Bubbling phase on ' + event.currentTarget.tagName);
}, false); // `false` или опускание аргумента указывает на фазу всплывания
```

### Значение Event Capturing

Фаза перехвата позволяет разработчикам устанавливать обработчики на высокоуровневые элементы в дереве DOM, чтобы перехватывать события до их достижения целевых элементов. Это может быть полезно для реализации общей предварительной логики обработки событий на уровне приложения или для предотвращения распространения события по дереву DOM.

# Event targer and Event current target
В контексте обработки событий в JavaScript, `event.target` и `event.currentTarget` относятся к различным элементам в процессе распространения события. Вот различия между ними:

### `event.target`

- `event.target` ссылается на элемент, на котором изначально было сгенерировано событие. Это самый глубокий элемент в DOM, вызвавший событие.
- Независимо от того, на каком уровне обработчика вы находитесь (в фазе перехвата или всплывания), `event.target` будет всегда указывать на элемент, с которого началось событие.
- Например, если у вас есть вложенные элементы, и вы кликнули на внутренний элемент, `event.target` будет этим внутренним элементом, даже если обработчик событий установлен на родительский элемент.

### Пример `event.target`

```html
<div id="parent">
    <button id="child">Click me</button>
</div>
```

```javascript
document.getElementById('parent').addEventListener('click', (event) => {
    console.log(event.target.id);  // Выведет "child" при клике на кнопку
});
```

### `event.currentTarget`

- `event.currentTarget` ссылается на элемент, к которому в данный момент прикреплён обработчик событий, который сейчас выполняется.
- В отличие от `event.target`, `event.currentTarget` меняется в зависимости от элемента, на котором обработчик был вызван в процессе распространения события.
- Если вы устанавливаете обработчик событий на родительский элемент и внутренний элемент инициирует событие, `event.currentTarget` будет равен родительскому элементу в обработчике, прикреплённом к родителю.

### Пример `event.currentTarget`

```javascript
document.getElementById('parent').addEventListener('click', (event) => {
    console.log(event.currentTarget.id);  // Выведет "parent", независимо от того, где был сделан клик внутри родителя
});
```

### Заключение

- Используйте `event.target`, чтобы получить элемент, на котором событие было изначально сгенерировано.
- Используйте `event.currentTarget` для доступа к элементу, который в данный момент обрабатывает событие (где был установлен обработчик событий).

Это различие особенно полезно при работе с вложенными элементами и делегировании событий, позволяя точно определить, где именно произошло событие и какой элемент его обрабатывает.

# Observer API что это
Observer API в контексте веб-разработки относится к различным API, которые позволяют отслеживать и реагировать на изменения в браузере или документе. Эти API используют паттерн "наблюдатель" (observer pattern), который позволяет подписываться на события или изменения и реагировать на них. Вот несколько ключевых Observer API в веб-разработке:

1. **MutationObserver**: Этот API позволяет отслеживать изменения в DOM (Document Object Model). Вы можете наблюдать за добавлением, удалением или изменением элементов в DOM, что полезно для реализации динамических интерфейсов. Например, мы можем отслеживать добавление новых элементов в список:

```javascript
// Выбираем целевой элемент, который будет наблюдаться
const target = document.querySelector('#myList');

// Конфигурация наблюдателя: что именно нужно отслеживать
const config = { childList: true };

// Callback-функция, которая будет выполнена при каждом изменении
const callback = function(mutationsList) {
    for (const mutation of mutationsList) {
        if (mutation.type === 'childList') {
            console.log('Добавлен новый элемент!');
        }
    }
};

// Создание экземпляра MutationObserver
const observer = new MutationObserver(callback);

// Начало наблюдения
observer.observe(target, config);

```

2. **IntersectionObserver**: С его помощью можно определять, когда элемент появляется или скрывается в области просмотра (viewport). Это широко используется для оптимизации загрузки контента, например, при ленивой загрузке изображений (lazy loading) или реализации бесконечной прокрутки.

```javascript
const img = document.querySelector('img.lazy-load');

const callback = (entries) => {
    entries.forEach(entry => {
        if (entry.isIntersecting) {
            const img = entry.target;
            img.src = img.dataset.src;
            img.classList.remove('lazy-load');
        }
    });
};

const observer = new IntersectionObserver(callback);
observer.observe(img);

```

3. **ResizeObserver**: Этот API позволяет отслеживать изменения размеров элементов DOM. Это полезно для создания реактивных дизайнов, которые адаптируются под размер контейнера или окна просмотра или реализации адаптивных компонентов.

```javascript
const box = document.querySelector('#resize-box');

const resizeObserver = new ResizeObserver(entries => {
    for (const entry of entries) {
        const { width, height } = entry.contentRect;
        console.log(`Размеры элемента: ${width}x${height}`);
    }
});

resizeObserver.observe(box);

```

4. **PerformanceObserver**: Используется для мониторинга и получения уведомлений о событиях, связанных с производительностью страницы, что позволяет более детально анализировать и оптимизировать загрузку и выполнение страницы.

```javascript
const perfObserver = new PerformanceObserver((list) => {
    for (const entry of list.getEntries()) {
        console.log(`Время загрузки ресурса: ${entry.name}: ${entry.duration}`);
    }
});

perfObserver.observe({ entryTypes: ["resource"] });
```

Эти API предоставляют мощные инструменты для разработчиков, позволяя более тонко управлять поведением и производительностью веб-страниц, реагируя на изменения в реальном времени без необходимости полагаться на более тяжёлые методы, такие как опрос или сложные обработчики событий.

# Cпособы ленивой загрузки изображения
Ленивая загрузка (lazy loading) изображений — это техника оптимизации, при которой загрузка ресурсов откладывается до того момента, когда они действительно нужны, например, когда пользователь прокручивает страницу и изображение появляется в области видимости. Вот несколько способов реализации ленивой загрузки изображений:

1. **Использование атрибута `loading` в теге `<img>`:**
   HTML5 предоставляет простой способ реализации ленивой загрузки с помощью атрибута `loading`, где `loading="lazy"` указывает браузеру отложить загрузку изображения, пока оно не понадобится.

   ```html
   <img src="example.jpg" loading="lazy" alt="Example image">
   ```

2. **IntersectionObserver API:**
   Этот API позволяет программно определить, когда элемент входит в область видимости экрана, и загрузить изображение в этот момент.

   ```javascript
   const observer = new IntersectionObserver((entries, observer) => {
     entries.forEach(entry => {
       if (entry.isIntersecting) {
         const img = entry.target;
         img.src = img.dataset.src;
         observer.unobserve(img);
       }
     });
   });

   document.querySelectorAll('img.lazy-load').forEach(img => observer.observe(img));
   ```

3. **Событие прокрутки (scroll event):**
   Можно использовать обработчик события прокрутки для проверки, находится ли изображение в области видимости, и загружать его при необходимости. Этот метод менее эффективен и может вызывать проблемы с производительностью при большом количестве изображений.

   ```javascript
   window.addEventListener('scroll', () => {
     const images = document.querySelectorAll('.lazy-load');
     images.forEach(img => {
       if (img.offsetTop < window.innerHeight + window.pageYOffset) {
         img.src = img.dataset.src;
         img.classList.remove('lazy-load');
       }
     });
   });
   ```

4. **Библиотеки и фреймворки:**
   Многие современные фреймворки и библиотеки, такие как React, Vue.js и Angular, предлагают встроенные или сторонние решения для ленивой загрузки изображений, которые облегчают интеграцию этой функциональности в приложения.

5. **CSS-триггеры:**
   Редко используемый подход, когда изображения загружаются только тогда, когда пользователь действует определенным образом, например, наводит курсор на элемент или кликает на него.

6. **Серверный рендеринг с заменой плейсхолдеров:**
   Изначально могут быть загружены легкие плейсхолдеры изображений, которые заменяются на полноценные изображения по мере прокрутки или в зависимости от другой логики загрузки.

Каждый из этих методов имеет свои преимущества и может быть выбран в зависимости от конкретных требований к производительности, поддержке браузера и сложности реализации.

# Ленивые вычисления в js 
Ленивые вычисления (lazy evaluation) — это стратегия вычисления, при которой оценка выражения откладывается до тех пор, пока её значение действительно не потребуется. В JavaScript ленивые вычисления не являются встроенной частью языка в такой степени, как в некоторых функциональных языках программирования (например, Haskell), но их можно эмулировать с помощью различных подходов.

### Примеры и техники реализации ленивых вычислений в JavaScript:

1. **Использование функций высшего порядка**:
   Функции могут возвращать другие функции, тем самым откладывая выполнение до момента, когда это действительно потребуется.

    ```javascript
    function lazySum(a, b) {
        return function() {
            return a + b;
        };
    }

    const lazyOperation = lazySum(5, 3);
    console.log(lazyOperation());  // Вычисление происходит здесь
    ```

2. **Использование геттеров для ленивых вычислений**:
   Геттеры в объектах могут использоваться для отложенных вычислений свойств.

    ```javascript
    const person = {
        firstName: 'John',
        lastName: 'Doe',
        get fullName() {
            console.log('Вычисление fullName');
            return `${this.firstName} ${this.lastName}`;
        }
    };

    console.log(person.fullName);  // Вычисление происходит при доступе к свойству
    ```

3. **Промисы и асинхронные операции**:
   Промисы в JavaScript позволяют управлять асинхронными операциями, выполняя их лениво, только когда это необходимо.

    ```javascript
    const fetchData = new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve("Данные получены");
        }, 1000);
    });

    // Данные будут запрошены только при вызове fetchData.then()
    fetchData.then(data => console.log(data));
    ```

4. **Генераторы и итераторы**:
   Генераторы предоставляют механизм для итерации по данным, генерируемым по требованию.

    ```javascript
    function* numberGenerator() {
        yield 1;
        yield 2;
        yield 3;
    }

    const generator = numberGenerator();

    console.log(generator.next().value);  // 1
    console.log(generator.next().value);  // 2
    ```

В этих примерах ленивые вычисления позволяют отложить выполнение тяжёлых операций или избежать их, если результаты этих операций не нужны. Это может значительно повысить производительность приложения, особенно в случаях, когда не все вычисленные данные требуются для каждого исполнения программы.